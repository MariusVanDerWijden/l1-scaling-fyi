<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ethereum L1 Gas Limit Scaling</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .container {
            width: 100%;
            max-width: 1000px;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .chart-card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .chart-container {
            position: relative;
            height: 400px;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #e5e7eb;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #6b7280;
            font-size: 0.875rem;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .footer {
            text-align: center;
            color: white;
            margin-top: 30px;
            font-size: 0.9rem;
        }

        .calculator-card {
            margin-top: 25px;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .calculator-header h2 {
            font-size: 1.75rem;
            color: #1f2937;
            margin-bottom: 5px;
        }

        .calculator-header p {
            color: #6b7280;
            font-size: 0.95rem;
        }

        .calculator-controls {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 25px;
            margin-top: 25px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-group label {
            font-weight: 600;
            color: #111827;
        }

        .control-group select,
        .control-group input[type="number"] {
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 0.95rem;
            background-color: #f9fafb;
        }

        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .slider-row input[type="range"] {
            width: 100%;
            accent-color: #667eea;
        }

        .slider-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .preset-button {
            padding: 6px 12px;
            border-radius: 9999px;
            border: 1px solid #cbd5f5;
            background: #eef2ff;
            color: #4c51bf;
            font-size: 0.85rem;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .preset-button:hover {
            background: #e0e7ff;
        }

        .blob-stats {
            display: flex;
            justify-content: space-between;
            gap: 15px;
            font-size: 0.9rem;
            color: #4b5563;
            flex-wrap: wrap;
        }

        .transfer-table {
            width: 100%;
            margin-top: 25px;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .transfer-table thead {
            background: #f3f4f6;
        }

        .transfer-table th,
        .transfer-table td {
            text-align: left;
            padding: 12px 15px;
        }

        .transfer-table tbody tr:nth-child(even) {
            background: #f9fafb;
        }

        .transfer-table tbody tr + tr {
            border-top: 1px solid #e5e7eb;
        }

        .transfer-table input[type="number"] {
            width: 100%;
        }

        .scenario-notes {
            color: #6b7280;
            font-size: 0.85rem;
        }

        .calculator-footnote {
            margin-top: 20px;
            color: #6b7280;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .roadblocks-card {
            margin-top: 25px;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .roadblocks-header h2 {
            font-size: 1.75rem;
            color: #1f2937;
            margin-bottom: 30px;
        }

        .roadblocks-list {
            list-style: none;
            padding: 0;
            margin: 0 auto;
            position: relative;
            padding-left: 40px;
            max-width: 800px;
        }

        .roadblocks-list::before {
            content: '';
            position: absolute;
            left: 15px;
            top: 0;
            bottom: 0;
            width: 3px;
            background: linear-gradient(180deg, #667eea 0%, #764ba2 100%);
            border-radius: 2px;
        }

        .roadblocks-list li {
            padding: 25px 0;
            position: relative;
            display: flex;
            align-items: flex-start;
            gap: 20px;
        }

        .roadblocks-list li::before {
            content: '';
            position: absolute;
            left: -32px;
            top: 28px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            border: 4px solid white;
            box-shadow: 0 0 0 3px #667eea;
            z-index: 1;
        }

        .roadblocks-list li:first-child::before {
            background: #10b981;
            box-shadow: 0 0 0 3px #10b981;
        }

        .roadblocks-list li:last-child {
            padding-bottom: 0;
        }

        .roadblock-gas {
            font-weight: 700;
            color: #667eea;
            min-width: 100px;
            flex-shrink: 0;
            font-size: 1.1rem;
        }

        .roadblock-description {
            color: #4b5563;
            line-height: 1.6;
            font-size: 1.05rem;
        }

        .roadblock-status {
            font-size: 0.95rem;
            color: #10b981;
            font-style: italic;
            font-weight: 500;
        }

        .faq-card {
            margin-top: 25px;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .faq-header h2 {
            font-size: 1.75rem;
            color: #1f2937;
            margin-bottom: 10px;
        }

        .faq-subtitle {
            color: #6b7280;
            font-size: 1rem;
            margin-bottom: 30px;
        }

        .faq-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .faq-item {
            margin-bottom: 30px;
            padding-bottom: 30px;
            border-bottom: 1px solid #e5e7eb;
        }

        .faq-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .faq-question {
            font-size: 1.15rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .faq-answer {
            color: #4b5563;
            line-height: 1.7;
            font-size: 1.05rem;
        }

        .faq-answer ul {
            margin: 15px 0;
            padding-left: 25px;
        }

        .faq-answer li {
            margin-bottom: 8px;
            line-height: 1.6;
        }

        .faq-answer strong {
            color: #1f2937;
            font-weight: 600;
        }

        .faq-answer a {
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
            transition: color 0.2s ease;
        }

        .faq-answer a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }
            .chart-container {
                height: 300px;
            }
            .stats {
                flex-direction: column;
                gap: 15px;
            }
            .calculator-controls {
                grid-template-columns: 1fr;
            }
            .blob-stats {
                flex-direction: column;
                align-items: flex-start;
            }
            .roadblocks-list {
                padding-left: 35px;
            }
            .roadblocks-list::before {
                left: 12px;
            }
            .roadblocks-list li::before {
                left: -27px;
            }
            .roadblocks-list li {
                flex-direction: column;
                gap: 10px;
            }
            .roadblock-gas {
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Ethereum L1 Gas Limit Scaling</h1>

        <div class="chart-card">
            <div class="chart-container">
                <canvas id="blobChart"></canvas>
            </div>

            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="currentCount">-</div>
                    <div class="stat-label">Current Gas Limit</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="currentMax">-</div>
                    <div class="stat-label">Current Max</div>
                </div>
            </div>
        </div>

        <div class="calculator-card">
            <div class="calculator-header">
                <h2>Transaction Throughput Estimator</h2>
                <p>Estimate transaction throughput based on gas limit and common transaction gas costs.</p>
            </div>

            <div class="calculator-controls">
                <div class="control-group">
                    <label for="milestoneSelect">Gas limit milestone</label>
                    <select id="milestoneSelect" aria-label="Select gas limit milestone">
                        <option>Loading milestones…</option>
                    </select>
                    <span class="scenario-notes" id="milestoneContext"></span>
                </div>
                <div class="control-group">
                    <label for="blobSlider">Gas limit per block</label>
                    <div class="slider-row">
                        <input type="range" id="blobSlider" min="10000000" max="200000000" value="30000000" step="1000000">
                        <div class="slider-buttons">
                            <button type="button" class="preset-button" data-preset="target">Use target</button>
                            <button type="button" class="preset-button" data-preset="max">Use max</button>
                        </div>
                    </div>
                    <div class="blob-stats">
                        <span id="blobCountDisplay">30M gas/block</span>
                        <span id="throughputDisplay">2.5 M gas/s</span>
                    </div>
                </div>
            </div>

            <table class="transfer-table">
                <thead>
                    <tr>
                        <th scope="col">Scenario</th>
                        <th scope="col">Gas cost per transaction</th>
                        <th scope="col">Est. TPS</th>
                        <th scope="col">Est. tx/block</th>
                    </tr>
                </thead>
                <tbody id="transferTableBody">
                    <!-- Populated by script -->
                </tbody>
            </table>

            <p class="calculator-footnote">
                Assumes 12 second Ethereum block time. Adjust the gas costs to explore different transaction types and complexity.
            </p>
        </div>

        <div class="roadblocks-card">
            <div class="roadblocks-header">
                <h2>Roadblocks</h2>
            </div>
            <ul class="roadblocks-list">
                <li>
                    <span class="roadblock-gas">60M gas:</span>
                    <span class="roadblock-description">
                        Fusaka repricing of Modexp <span class="roadblock-status">(already accomplished)</span>
                    </span>
                </li>
                <li>
                    <span class="roadblock-gas">80M gas:</span>
                    <span class="roadblock-description">
                        Glamsterdam repricing of worst cases, eth/70
                    </span>
                </li>
                <li>
                    <span class="roadblock-gas">100M gas:</span>
                    <span class="roadblock-description">
                        eth/71 or significant calldata repricing
                    </span>
                </li>
                <li>
                    <span class="roadblock-gas">120M gas+:</span>
                    <span class="roadblock-description">
                        Resource harmonizations and re-anchoring
                    </span>
                </li>
            </ul>
        </div>

        <div class="faq-card">
            <div class="faq-header">
                <h2>FAQ</h2>
            </div>
            <ul class="faq-list">
                <li class="faq-item">
                    <div class="faq-question">Why not just speed up the roadmap?</div>
                    <div class="faq-answer">
                        Security, stability, and consensus are our top priorities. Rushing upgrades on a network securing hundreds of billions of dollars is extremely risky. Every change requires extensive research, parallel implementation by multiple independent client teams, and rigorous testing. A rushed roadmap would inevitably lead to critical bugs and network instability.
                    </div>
                </li>
                <li class="faq-item">
                    <div class="faq-question">What hardware are you targeting?</div>
                    <div class="faq-answer">
                        We are committed to keeping Ethereum accessible. Our goal is to ensure the L1 can be reliably run on consumer-grade hardware. The specific hardware specifications we are using as a benchmark for development are outlined in <strong><a href="https://eips.ethereum.org/EIPS/eip-7870" target="_blank" rel="noopener noreferrer">EIP-7870</a></strong>.
                    </div>
                </li>
                <li class="faq-item">
                    <div class="faq-question">Will these changes hurt decentralization?</div>
                    <div class="faq-answer">
                        No. Protecting decentralization is a core goal of this roadmap. The hardware targets in <a href="https://eips.ethereum.org/EIPS/eip-7870" target="_blank" rel="noopener noreferrer">EIP-7870</a> are specifically chosen to ensure that running a full node remains feasible for individuals, not just large-scale data centers. This is critical to preventing the centralization of node operators.
                    </div>
                </li>
                <li class="faq-item">
                    <div class="faq-question">How can I contribute?</div>
                    <div class="faq-answer">
                        Community contributions are vital! You can help in several key ways:
                        <ul>
                            <li><strong>Write benchmarks:</strong> We always need more data. Write and run benchmarks for the proposed changes to help us understand their real-world impact on different hardware.</li>
                            <li><strong>Contribute to clients:</strong> All client teams (Geth, Nethermind, Besu, Erigon, etc.) need developers to help implement, test, and optimize the new EIPs.</li>
                            <li><strong>Spread the message:</strong> Help educate the community! Share high-quality information, participate in discussions, and help combat misinformation.</li>
                        </ul>
                    </div>
                </li>
                <li class="faq-item">
                    <div class="faq-question">Are any of these numbers (gas costs, block limits) final?</div>
                    <div class="faq-answer">
                        No. All numbers discussed in proposals, EIPs, and presentations are estimates and are subject to change. They are used for research and modeling. Final parameters will only be set after extensive testing, benchmarking, and community consensus.
                    </div>
                </li>
                <li class="faq-item">
                    <div class="faq-question">How will gas repricings impact this?</div>
                    <div class="faq-answer">
                        The concept of "gas" will likely evolve. Gas will not mean the same anymore after the significant reprcings we are proposing. All numbers we are proposing here are subject to significant change and should illustrate how we are planning to scale compared to todays gas schedule.
                    </div>
                </li>
                <li class="faq-item">
                    <div class="faq-question">How will existing smart contracts be impacted by repricings?</div>
                    <div class="faq-answer">
                        When gas costs change, some operations will inevitably become more expensive (e.g., storage access), while most others (e.g., computation) will become significantly cheaper. We are analyzing existing on-chain data to understand this impact. The core goal is to break as few existing applications as possible while unlocking new, cheaper use cases.
                    </div>
                </li>
            </ul>
        </div>

        <div class="footer" id="lastUpdated"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        let chart;
        const BLOCK_TIME_SECONDS = 12;

        function formatGasNumber(value) {
            if (value >= 1000000) {
                return (value / 1000000).toFixed(0) + 'M';
            } else if (value >= 1000) {
                return (value / 1000).toFixed(0) + 'K';
            }
            return value.toString();
        }

        const transferProfiles = [
            {
                id: 'eth-transfer',
                label: 'ETH transfer',
                defaultSize: 21000,
                notes: 'Simple ETH transfer (21,000 gas)'
            },
            {
                id: 'erc20-transfer',
                label: 'ERC-20 transfer',
                defaultSize: 65000,
                notes: 'Token transfer with contract interaction (~65,000 gas)'
            },
            {
                id: 'uniswap-trade',
                label: 'Uniswap swap',
                defaultSize: 150000,
                notes: 'DEX swap transaction (~150,000 gas)'
            }
        ];

        async function loadData() {
            try {
                const response = await fetch('data.json');
                const data = await response.json();

                // Display last updated date
                if (data.lastUpdated) {
                    const [year, month, day] = data.lastUpdated.split('-');
                    const date = new Date(year, month - 1, day);
                    const formattedDate = date.toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                    document.getElementById('lastUpdated').innerHTML = `Projected data (open points on chart) are subject to change<br>Last updated: ${formattedDate}`;
                }

                return data.blobData;
            } catch (error) {
                console.error('Error loading data:', error);
                return [];
            }
        }

        function calculateStats(data) {
            if (data.length === 0) return { current: 0, max: 0 };

            // Get today's date
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Reset time to start of day

            // Find the most recent upgrade that has already occurred
            let currentTarget = 0;
            let currentMax = 0;

            for (const item of data) {
                const [year, month, day] = item.date.split('-');
                const upgradeDate = new Date(year, month - 1, day);

                if (upgradeDate <= today && !item.projected) {
                    currentTarget = item.target;
                    currentMax = item.max;
                }
            }

            return {
                current: formatGasNumber(currentTarget),
                max: formatGasNumber(currentMax)
            };
        }

        function initCalculator(blobData) {
            const milestoneSelect = document.getElementById('milestoneSelect');
            const milestoneContext = document.getElementById('milestoneContext');
            const blobSlider = document.getElementById('blobSlider');
            const blobCountDisplay = document.getElementById('blobCountDisplay');
            const throughputDisplay = document.getElementById('throughputDisplay');
            const tableBody = document.getElementById('transferTableBody');

            if (!milestoneSelect || !blobSlider || !tableBody || !blobCountDisplay || !throughputDisplay) return;

            milestoneSelect.innerHTML = '';
            blobData.forEach((milestone, index) => {
                const option = document.createElement('option');
                const dateLabel = formatUpgradeDate(milestone.date);
                const projectedNotation = milestone.projected ? ' (projected)' : '';
                option.value = String(index);
                option.textContent = `${milestone['upgrade-name']} – ${dateLabel}${projectedNotation}`;
                milestoneSelect.appendChild(option);
            });

            // Find the most recent milestone relative to today's date
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            let defaultIndex = 0;
            for (let i = blobData.length - 1; i >= 0; i--) {
                const [year, month, day] = blobData[i].date.split('-');
                const milestoneDate = new Date(year, month - 1, day);

                if (milestoneDate <= today) {
                    defaultIndex = i;
                    break;
                }
            }

            milestoneSelect.value = String(defaultIndex);

            tableBody.innerHTML = '';
            transferProfiles.forEach(profile => {
                const row = document.createElement('tr');
                row.dataset.profileId = profile.id;

                const scenarioCell = document.createElement('td');
                scenarioCell.innerHTML = `<strong>${profile.label}</strong><div class="scenario-notes">${profile.notes}</div>`;

                const inputCell = document.createElement('td');
                const input = document.createElement('input');
                input.type = 'number';
                input.min = '1';
                input.value = profile.defaultSize;
                input.dataset.profileId = profile.id;
                input.setAttribute('aria-label', `${profile.label} gas cost per transaction`);
                input.addEventListener('input', updateCalculations);
                inputCell.appendChild(input);

                const tpsCell = document.createElement('td');
                tpsCell.className = 'tps-output';
                tpsCell.textContent = '—';

                const txPerBlockCell = document.createElement('td');
                txPerBlockCell.className = 'tx-per-block-output';
                txPerBlockCell.textContent = '—';

                row.appendChild(scenarioCell);
                row.appendChild(inputCell);
                row.appendChild(tpsCell);
                row.appendChild(txPerBlockCell);
                tableBody.appendChild(row);
            });

            milestoneSelect.addEventListener('change', () => {
                updateSliderFromMilestone();
                applyMilestoneContext();
                updateCalculations();
            });

            blobSlider.addEventListener('input', () => {
                updateBlobStats();
                updateCalculations();
            });

            document.querySelectorAll('.preset-button').forEach(button => {
                button.addEventListener('click', () => {
                    const selectedMilestone = getSelectedMilestone(blobData, milestoneSelect.value);
                    if (!selectedMilestone) return;

                    const preset = button.dataset.preset;
                    const targetValue = preset === 'target' ? selectedMilestone.target : selectedMilestone.max;
                    if (targetValue !== undefined && targetValue !== null && Number.isFinite(Number(targetValue))) {
                        blobSlider.value = String(Number(targetValue));
                        updateBlobStats();
                        updateCalculations();
                    }
                });
            });

            function updateSliderFromMilestone() {
                const selectedMilestone = getSelectedMilestone(blobData, milestoneSelect.value);
                if (!selectedMilestone) return;

                const upperBound = Math.max(
                    Number(selectedMilestone.target) || 10000000,
                    Number(selectedMilestone.max) || 0,
                    10000000
                );
                blobSlider.min = '10000000';
                const sliderMax = Math.max(upperBound, Number(blobSlider.value) || 30000000, Number(blobSlider.min) || 10000000);
                blobSlider.max = String(Math.max(sliderMax, 200000000));
                blobSlider.step = '1000000';
                blobSlider.value = String(Number(selectedMilestone.target) || 30000000);
                updateBlobStats();
            }

            function applyMilestoneContext() {
                const selectedMilestone = getSelectedMilestone(blobData, milestoneSelect.value);
                const targetButton = document.querySelector('.preset-button[data-preset="target"]');
                const maxButton = document.querySelector('.preset-button[data-preset="max"]');

                if (selectedMilestone) {
                    if (milestoneContext) {
                        milestoneContext.textContent = selectedMilestone.projected
                            ? 'Projected milestone based on roadmap targets.'
                            : 'Live network milestone.';
                    }

                    if (targetButton) {
                        if (selectedMilestone.target) {
                            const targetFormatted = formatGasNumber(Number(selectedMilestone.target));
                            targetButton.textContent = `Target (${targetFormatted})`;
                            targetButton.disabled = false;
                        } else {
                            targetButton.textContent = 'Target (n/a)';
                            targetButton.disabled = true;
                        }
                    }

                    if (maxButton) {
                        if (selectedMilestone.max) {
                            const maxFormatted = formatGasNumber(Number(selectedMilestone.max));
                            maxButton.textContent = `Max (${maxFormatted})`;
                            maxButton.disabled = false;
                        } else {
                            maxButton.textContent = 'Max (n/a)';
                            maxButton.disabled = true;
                        }
                    }
                } else {
                    if (milestoneContext) {
                        milestoneContext.textContent = 'Milestone data unavailable.';
                    }
                    if (targetButton) {
                        targetButton.textContent = 'Target (n/a)';
                        targetButton.disabled = true;
                    }
                    if (maxButton) {
                        maxButton.textContent = 'Max (n/a)';
                        maxButton.disabled = true;
                    }
                }
            }

            function updateBlobStats() {
                const gasLimit = Number(blobSlider.value) || 0;
                const gasPerSecond = gasLimit / BLOCK_TIME_SECONDS;
                const gasPerSecondM = gasPerSecond / 1000000;

                blobCountDisplay.textContent = `${formatGasNumber(gasLimit)} gas/block`;
                throughputDisplay.textContent = `${gasPerSecondM.toFixed(2)} M gas/s`;
            }

            function updateCalculations() {
                const gasLimit = Number(blobSlider.value) || 0;
                const gasPerSecond = gasLimit / BLOCK_TIME_SECONDS;

                tableBody.querySelectorAll('tr').forEach(row => {
                    const input = row.querySelector('input[type="number"]');
                    const tpsCell = row.querySelector('.tps-output');
                    const txPerBlockCell = row.querySelector('.tx-per-block-output');
                    if (!input || !tpsCell || !txPerBlockCell) return;

                    const gasCost = Number(input.value);
                    if (!gasCost || gasCost <= 0) {
                        tpsCell.textContent = '—';
                        txPerBlockCell.textContent = '—';
                        return;
                    }

                    const tps = gasPerSecond / gasCost;
                    const fractionDigits = tps >= 100 ? 0 : 1;
                    const formatted = tps.toLocaleString(undefined, {
                        minimumFractionDigits: fractionDigits,
                        maximumFractionDigits: fractionDigits
                    });
                    tpsCell.textContent = `${formatted} tx/s`;

                    const txPerBlock = Math.floor(gasLimit / gasCost);
                    const txPerBlockFormatted = txPerBlock.toLocaleString(undefined, {
                        minimumFractionDigits: 0,
                        maximumFractionDigits: 0
                    });
                    txPerBlockCell.textContent = `${txPerBlockFormatted} tx`;
                });
            }

            updateSliderFromMilestone();
            applyMilestoneContext();
            updateCalculations();
        }

        function getSelectedMilestone(blobData, selectedIndex) {
            const index = Number(selectedIndex);
            if (!Array.isArray(blobData) || Number.isNaN(index) || index < 0 || index >= blobData.length) {
                return null;
            }
            return blobData[index];
        }

        function formatUpgradeDate(dateString) {
            if (!dateString) return 'TBD';
            const [year, month, day] = dateString.split('-');
            const parsedDate = new Date(year, month - 1, day);
            if (Number.isNaN(parsedDate.getTime())) return 'TBD';
            return parsedDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        }

        async function initChart() {
            const blobData = await loadData();

            initCalculator(blobData);

            const stats = calculateStats(blobData);
            document.getElementById('currentCount').textContent = stats.current;
            document.getElementById('currentMax').textContent = stats.max;

            const ctx = document.getElementById('blobChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: blobData.map(d => {
                        // Parse date as local time, not UTC
                        const [year, month, day] = d.date.split('-');
                        const date = new Date(year, month - 1, day);
                        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                    }),
                    datasets: [{
                        label: 'Gas Limit',
                        data: blobData.map(d => d.target),
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointBackgroundColor: blobData.map(d => d.projected ? '#fff' : '#10b981'),
                        pointBorderColor: blobData.map(d => '#10b981'),
                        pointBorderWidth: blobData.map(d => d.projected ? 3 : 2),
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        yAxisID: 'y',
                        segment: {
                            borderDash: ctx => {
                                const idx = ctx.p1DataIndex;
                                // If either point is projected, make the segment dashed
                                return (idx > 0 && (blobData[idx].projected || blobData[idx - 1].projected)) ? [5, 5] : undefined;
                            }
                        }
                    }, {
                        label: 'Max',
                        data: blobData.map(d => d.max),
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointBackgroundColor: blobData.map(d => d.projected ? '#fff' : '#3b82f6'),
                        pointBorderColor: blobData.map(d => '#3b82f6'),
                        pointBorderWidth: blobData.map(d => d.projected ? 3 : 2),
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        yAxisID: 'y',
                        segment: {
                            borderDash: ctx => {
                                const idx = ctx.p1DataIndex;
                                // If either point is projected, make the segment dashed
                                return (idx > 0 && (blobData[idx].projected || blobData[idx - 1].projected)) ? [5, 5] : undefined;
                            }
                        }
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                padding: 15,
                                usePointStyle: true,
                                font: {
                                    size: 12
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            cornerRadius: 8,
                            callbacks: {
                                title: function(context) {
                                    const index = context[0].dataIndex;
                                    // Parse date as local time, not UTC
                                    const [year, month, day] = blobData[index].date.split('-');
                                    const date = new Date(year, month - 1, day);
                                    const upgradeName = blobData[index]['upgrade-name'];
                                    const isProjected = blobData[index].projected;
                                    return [
                                        upgradeName + ' Upgrade' + (isProjected ? ' (Projected)' : ''),
                                        date.toLocaleDateString('en-US', {
                                            year: 'numeric',
                                            month: 'long',
                                            day: 'numeric'
                                        })
                                    ];
                                },
                                label: function(context) {
                                    const gasLimit = context.parsed.y;
                                    const gasPerSecond = gasLimit / BLOCK_TIME_SECONDS;
                                    const gasPerSecondM = gasPerSecond / 1000000;
                                    return context.dataset.label + ': ' + formatGasNumber(gasLimit) + ' gas/block (' + gasPerSecondM.toFixed(2) + ' M gas/s)';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            beginAtZero: false,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return formatGasNumber(value);
                                }
                            },
                            title: {
                                display: true,
                                text: 'Gas Limit per Block'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            beginAtZero: false,
                            grid: {
                                drawOnChartArea: false
                            },
                            min: function(context) {
                                // Match the min of the left axis
                                return context.chart.scales.y.min;
                            },
                            max: function(context) {
                                // Match the max of the left axis
                                return context.chart.scales.y.max;
                            },
                            afterBuildTicks: function(scale) {
                                // Filter out ticks that would be below 0.5 M gas/s
                                scale.ticks = scale.ticks.filter(tick => {
                                    const gasPerSecond = tick.value / BLOCK_TIME_SECONDS;
                                    const gasPerSecondM = gasPerSecond / 1000000;
                                    return gasPerSecondM >= 0.5;
                                });
                            },
                            ticks: {
                                callback: function(value) {
                                    // Convert gas/block to M gas/s
                                    const gasPerSecond = value / BLOCK_TIME_SECONDS;
                                    const gasPerSecondM = gasPerSecond / 1000000;
                                    return gasPerSecondM.toFixed(2) + ' M gas/s';
                                }
                            },
                            title: {
                                display: true,
                                text: 'Throughput (M gas/s)'
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        }

        initChart();
    </script>
</body>
</html>
